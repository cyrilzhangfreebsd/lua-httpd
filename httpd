#!/usr/libexec/flua
-- vim: set et:
-- Minimal web server written in Lua
--
-- Use with inetd, no other dependencies:
-- http    stream  tcp     nowait  root    /usr/local/sbin/httpd      httpd

--
-- Copyright (c) 2016 - 2020 Ryan Moeller <ryan@freqlabs.com>
--
-- Permission to use, copy, modify, and distribute this software for any
-- purpose with or without fee is hereby granted, provided that the above
-- copyright notice and this permission notice appear in all copies.
--
-- THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-- WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-- MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-- ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-- WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-- ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-- OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

local SRC_DIR = "/home/yang/src/lua-httpd/"

package.path = SRC_DIR .. "?.lua;" .. package.path

local httpd = require("httpd")
local template = require("template")

local boot = require("boot")
local disk = require("disk")
local distset = require("distset")
local filesystem = require("filesystem")
local hardening = require("hardening")
local keymap = require("keymap")
local partition = require("partition")
local service = require("service")
local shell = require("shell")
local network = require("network")
local db = require("db")

local misc = require("misc")
local json = require("json")

--local manifest = "/usr/local/share/freebsd/MANIFESTS/amd64-amd64-13.0-RELEASE"
local manifest = SRC_DIR .. "MANIFEST"

local main_page_file = assert(io.open(SRC_DIR .. "main_page.html", "r"))
local main_page = main_page_file:read("*all")
main_page_file:close()

local add_user_file= assert(io.open(SRC_DIR .. "add_user.html", "r"))
local add_user_page = add_user_file:read("*all")
add_user_file:close()

local network_file = assert(io.open(SRC_DIR .. "network.html", "r"))
local network_page = network_file:read("*all")
network_file:close()

local keymap_file = assert(io.open(SRC_DIR .. "keymap.html", "r"))
local keymap_page = keymap_file:read("*all")
keymap_file:close()

local zfs_file = assert(io.open(SRC_DIR .. "zfs.html", "r"))
local zfs_page = zfs_file:read("*all")
zfs_file:close()

function pairs_by_keys(t, f)
        local a = {}
        for n in pairs(t) do table.insert(a, n) end
        table.sort(a, f)
        local i = 0 -- iterator variable
        local iter = function() -- iterator function
                i = i + 1
                if a[i] == nil then return nil
                else return a[i], t[a[i]]
                end
        end
        return iter
end

function selected(cond)
        return cond and "selected" or ""
end

function readonly(cond)
        return cond and "readonly" or ""
end

function wireless(cond)
        return cond and "[Wireless]" or "[Wired]"
end

function disabled(cond)
        return cond and "disabled" or ""
end

function orEmpty(string)
        if (string) then
                return string
        else
                return ""
        end
       -- return string and string or ""
end

function orWheel(string)
        if (string) then
                return string
        else
                return "wheel"
        end
       -- return string and string or ""
end

--TODO: properly credit
function unescape (str)
        str = string.gsub (str, "+", " ")
        str = string.gsub (str, "%%(%x%x)", function(h) return string.char(tonumber(h,16)) end)
        return str
end

function splitString(str, char)
        local split_list = {}

        for match in str:gmatch("[^" .. char .. "]+") do
                table.insert(split_list, match)
        end
        return split_list
end

function parseRequest(body)
        local lines = splitString(body, "&")
        local req = {}

        for i, line in ipairs(lines) do
                local mapping = unescape(line)
                local key, val = mapping:match("^([^=]+)=(.*)")

                --requests could possibly have multiple vals per key. Put the values into an array
                if (type(req[key]) == "string") then
                       req[key] = {req[key], val}
                elseif (type(req[key]) == "table") then
                        table.insert(req[key], val)
                else
                        req[key] = val
                end
        end

        return req
end

function mainPage(request)
        local lang = request.matches[1]
        if lang == "" then
                lang = "en"
        end

        local parsed_db = db:parse()

        local body = template.process(main_page,
                { theme = "cerulean", -- "darkly", -- NB: the Bulmaswatch themes are broken atm
                lang = lang,
                boothowto = boot.howto(),
                bootmethod = boot.method(),
                disks = disk.info(),
                distsets = distset.list(manifest),
                filesystem_formats = filesystem.formats,
                hardening_menu = hardening.menu,
                partition_styles = partition.styles,
                service_menu = service.menu,
                shells = shell.list,
                users = db:getUsersAsList(parsed_db),
        })
        return { status=200, reason="ok", body=body }
end

function zfsPage(request)
        local body = template.process(zfs_page,
        {
                theme = "cerulean",
                disks = disk.info(),
                filesystem_formats = filesystem.zfs_formats
        })

        return { status=200, reason="ok", body = body }
end

function setZFS(request)
        local req = parseRequest(request.body)

        local disks = ""
        for _, disk in ipairs(req.disk) do
                disks = disk .. " " .. disks
        end

        db:update("zfs_filesystem", req.filesystem)
        db:update("zfs_disks", disks)

        return { status=303, headers = {["Location"]="/"}, reason="ok", body = "TODO" }
end

function keymapPage(request)
        local parsed_db = db:parse()
        local selected_layout = parsed_db.keymap_layout
        local selected_variant = parsed_db.keymap_variant
        local variants = keymap.XMap[selected_layout]

        local body = template.process(keymap_page,
        {
                theme = "cerulean",
                lang = "en", --TODO: put this in the config eventually?
                x_list = keymap.XList,
                x_variants = variants,
                selected_layout = selected_layout,
                selected_variant = selected_variant,
        })

        return { status=200, reason="ok", body = body }
end

function getVariants(request)
        local variants = keymap.XMap[request.matches[1]]
        return { status=200, reason="ok", body=json.encode(variants)}
end

function setKeymap(request)
        local keymap = json.decode(request.body)

        if (keymap.variant == "") then
                os.execute("XAUTHORITY=/home/yang/.Xauthority setxkbmap -display :0 " .. keymap.layout) --This is somewhat of a hack. TODO: figure out how to do this better
        else
                os.execute("XAUTHORITY=/home/yang/.Xauthority setxkbmap -display :0 " .. keymap.layout .. " -variant " .. keymap.variant)
        end

        return { status=200, reason="ok", body = keymap.layout}
end

function writeKeymap(request)
        local req = parseRequest(request.body)
        db:update("keymap_layout", req.keymap)
        db:update("keymap_variant", req.variant)
        
        return { status=303, headers = {["Location"]="/"}, reason="ok", body = "TODO" }
end

function addUserPage(request)
        local body = template.process(add_user_page,
        {
                theme = "cerulean",
                shells = shell.list,
        })

        return { status=200, reason="ok", body = body }
end

function editUserPage(request)
        local username = request.matches[1]

        local user_data = db:parse().users[username]

        local body = template.process(add_user_page,
        {
                theme = "cerulean",
                shells = shell.list,
                username = username,
                real_name = user_data.real_name,
                user_shell = user_data.shell,
                groups = user_data.groups,
                editing = true,
        })

        return { status=200, reason="ok", body = body }
end

function addUser(request)
        local req = parseRequest(request.body)

        --TODO verify input

        db:update("user:"..req.username..":real_name", req.real_name)
        db:update("user:"..req.username..":password", req.password)
        db:update("user:"..req.username..":groups", req.groups)
        db:update("user:"..req.username..":shell", req.shell)

        return { status=303, headers = {["Location"]="/#users"}, reason="ok", body = "TODO" }
end

function deleteUser(request)
        local username = request.matches[1]

        --TODO verify input

        db:removeMatches("^user:"..username)

        return { status=303, headers = {["Location"]="/#users"}, reason="ok", body = "TODO" }
end

function networkPage(request)
        local body = template.process(network_page,
        {
                theme = "cerulean",
                network_interfaces = network.getInterfaces(),
        })

        return { status=200, reason="ok", body = body }
end

function checkIsWireless(request)
        local isWireless = network.isWireless(request.matches[1])
        return {status=200, reason="ok", body=json.encode(isWireless)}
end

function scanWireless(request)
        local networks = network.scanWireless()
        return { status=200, reason="ok", body=json.encode(networks)}
end

function connectToNetwork(request)
        local req = parseRequest(request.body)
        local cfg = {}
        for key, val in pairs(req) do
                cfg[key] = val
                print(key, val)
        end

        --add wired support too...
        --and dhcp, slaac stuff
        --network.connectWireless(cfg.network, cfg.password)

        return { status=303, headers = {["Location"]="/"}, reason="ok", body = "TODO" }
end


function doInstall(request)
        local lines = splitString(request.body, "&")

        local distsets = ""
        local disks = ""

        --[[
        local cfg = {}

        for i, line in ipairs(lines) do
                local mapping = unescape(line)

                local key, val = mapping:match("^([^=]+)=(.*)")
                if (key == "distsets") then
                        distsets = val .. " " .. distsets
                elseif (key == "disks") then
                        disks = val .. " " .. disks
                else
                        cfg[key] = val
                end
        end

        db:seek("end")
        for key, val in pairs(cfg) do
                db:write(key .. "=" .. val .. "\n") 
        end

        db:write("partitions=" .. disks .. "\n")
        db:write("distributions=" .. distsets .. "\n")
        ]]--

        return { status=501, reason="Not implemented", body="TODO" }
end

local server = httpd.create_server("/var/log/httpd.log")

--Fetch API stuff
server:add_route("GET", "^/keymap/variants/(.*)$", getVariants)
server:add_route("GET", "^/network/iswireless/(.*)$", checkIsWireless)
server:add_route("GET", "^/scanwireless$", scanWireless)
server:add_route("POST", "^/setkeymap$", setKeymap)

--Pages
server:add_route("GET", "^/zfs$", zfsPage)
server:add_route("GET", "^/adduser$", addUserPage)
server:add_route("GET", "^/edituser/(.*)$", editUserPage)
server:add_route("GET", "^/network$", networkPage)
server:add_route("GET", "^/keymap$", keymapPage)
server:add_route("GET", "^/(.*)$", mainPage)

server:add_route("POST", "^/zfs$", setZFS)
server:add_route("POST", "^/install$", doInstall)
server:add_route("POST", "^/adduser$", addUser)
server:add_route("POST", "^/deleteuser/(.*)$", deleteUser)
server:add_route("POST", "^/network$", connectToNetwork)
server:add_route("POST", "^/writekeymap$", writeKeymap)

server:run(true)
