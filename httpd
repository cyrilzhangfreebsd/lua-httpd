#!/usr/libexec/flua
-- vim: set et:
-- Minimal web server written in Lua
--
-- Use with inetd, no other dependencies:
-- http    stream  tcp     nowait  root    /usr/local/sbin/httpd      httpd

--
-- Copyright (c) 2016 - 2020 Ryan Moeller <ryan@freqlabs.com>
--
-- Permission to use, copy, modify, and distribute this software for any
-- purpose with or without fee is hereby granted, provided that the above
-- copyright notice and this permission notice appear in all copies.
--
-- THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-- WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-- MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-- ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-- WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-- ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-- OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

local SRC_DIR = "/home/yang/src/lua-httpd/"

package.path = SRC_DIR .. "?.lua;" .. package.path

local httpd = require("httpd")
local template = require("template")

local boot = require("boot")
local disk = require("disk")
local distset = require("distset")
local filesystem = require("filesystem")
local hardening = require("hardening")
local keymap = require("keymap")
local partition = require("partition")
local service = require("service")
local shell = require("shell")
local network = require("network")

local misc = require("misc")
local json = require("json")

--local manifest = "/usr/local/share/freebsd/MANIFESTS/amd64-amd64-13.0-RELEASE"
local manifest = SRC_DIR .. "MANIFEST"

local db_file = SRC_DIR .. "db"
local db = io.open(db_file, "r+")

local main_page_file = assert(io.open(SRC_DIR .. "main_page.html", "r"))
local main_page = main_page_file:read("*all")
main_page_file:close()

local add_user_file= assert(io.open(SRC_DIR .. "add_user.html", "r"))
local add_user_page = add_user_file:read("*all")
add_user_file:close()

local network_file = assert(io.open(SRC_DIR .. "network.html", "r"))
local network_page = network_file:read("*all")
network_file:close()

local keymap_file = assert(io.open(SRC_DIR .. "keymap.html", "r"))
local keymap_page = keymap_file:read("*all")
keymap_file:close()

function pairs_by_keys(t, f)
        local a = {}
        for n in pairs(t) do table.insert(a, n) end
        table.sort(a, f)
        local i = 0 -- iterator variable
        local iter = function() -- iterator function
                i = i + 1
                if a[i] == nil then return nil
                else return a[i], t[a[i]]
                end
        end
        return iter
end

function selected(cond)
        return cond and "selected" or ""
end

function readonly(cond)
        return cond and "readonly" or ""
end

function wireless(cond)
        return cond and "[Wireless]" or "[Wired]"
end

function disabled(cond)
        return cond and "disabled" or ""
end

function orEmpty(string)
        if (string) then
                return string
        else
                return ""
        end
       -- return string and string or ""
end

function orWheel(string)
        if (string) then
                return string
        else
                return "Wheel"
        end
       -- return string and string or ""
end

--TODO: properly credit
function unescape (str)
        str = string.gsub (str, "+", " ")
        str = string.gsub (str, "%%(%x%x)", function(h) return string.char(tonumber(h,16)) end)
        return str
end

function splitString(str, char)
        local split_list = {}

        for match in str:gmatch("[^" .. char .. "]+") do
                table.insert(split_list, match)
        end
        return split_list
end

function parseRequest(body)
        local lines = splitString(body, "&")
        local req = {}

        for i, line in ipairs(lines) do
                local mapping = unescape(line)

                local key, val = mapping:match("^([^=]+)=(.*)")
                req[key] = val
        end

        return req
end

function parseDB()
        db:seek("set")
        local contents = db:read("*all")
        local lines = splitString(contents, "\n")
        local table = {users = {}}

        for i, line in ipairs(lines) do
                if (line:match("user:")) then --TODO make this logic better
                        local username, prop, val = line:match("^[^:]+:([^.]+).([^=]+)=(.*)")
                        if (table.users[username] == nil) then
                                table.users[username] = {}
                        end
                        table.users[username][prop] = val
                else
                        local prop, val = line:match("^([^=]+)=(.*)")
                        table[prop] = val
                end
        end

        return table
end

function mainPage(request)
        local lang = request.matches[1]
        if lang == "" then
                lang = "en"
        end

        local body = template.process(main_page,
                { theme = "cerulean", -- "darkly", -- NB: the Bulmaswatch themes are broken atm
                lang = lang,
                boothowto = boot.howto(),
                bootmethod = boot.method(),
                disks = disk.info(),
                distsets = distset.list(manifest),
                filesystem_formats = filesystem.formats,
                hardening_menu = hardening.menu,
                partition_styles = partition.styles,
                service_menu = service.menu,
                shells = shell.list,
                users = getUsersAsList(),
        })
        return { status=200, reason="ok", body=body }
end


function keymapPage(request)
        local _, keymap_menu = keymap.index(keymap.VT)
        local body = template.process(keymap_page,
        {
                theme = "cerulean",
                lang = "en", --put this in the config eventually?
                keymap_menu = keymap_menu,
                keymap_x_list = keymap.XList,
        })

        return { status=200, reason="ok", body = body }
end

function getVariants(request)
        local variants = keymap.XMap[request.matches[1]]
        return { status=200, reason="ok", body=json.encode(variants)}
end

function setKeymap(request)
        local keymap = json.decode(request.body)
        
        if (keymap.variant == "") then
                os.execute("setxkbmap -display :0 " .. keymap.layout)
        else
                os.execute("setxkbmap " .. keymap.layout .. " -variant " .. keymap.variant)
        end

      --[[
        local keymap_file = io.open("/usr/local/etc/X11/xorg.conf.d/default_keyboard.conf", "w+")
        keymap_file:write("Section \"InputClass\"\n")
        keymap_file:write("\tIdentifier\t\"Default-Keyboard\"\n")
        keymap_file:write("\tMatchIsKeyboard\t\"on\"\n")
        keymap_file:write("\tXkbLayout\t\""..keymap.layout.."\"\n")
        if (keymap.variant ~= "") then
                keymap_file:write("\tXkbVariant\t\""..keymap.variant.."\"\n")
        end
        keymap_file:write("EndSection\n")
        ]]--

        return { status=200, reason="ok", body = keymap.layout}
end

function addUserPage(request)
        local body = template.process(add_user_page,
        {
                theme = "cerulean",
                shells = shell.list,
        })

        return { status=200, reason="ok", body = body }
end

function editUserPage(request)
        local username = request.matches[1]

        local userData = parseDB().users[username]

        local body = template.process(add_user_page,
        {
                theme = "cerulean",
                shells = shell.list,
                username = username,
                real_name = userData.real_name,
                user_shell = userData.shell,
                groups = userData.groups,
                editing = true,
        })

        return { status=200, reason="ok", body = body }
end

function getUsersAsList()
        local users = parseDB().users
        local user_list = {}

        for username, props in pairs(users) do
                local user = {}
                user.username = username
                for key, val in pairs(props) do
                        user[key] = val
                end
                table.insert(user_list, user)
        end

        local function compare_users(this, other)
            return this.username < other.username
        end

        table.sort(user_list, compare_users)

        return user_list
end

function removeUserFromDB(username)
        db:seek("set")
        local text = db:read("*all")
        db:close()
        db = io.open(db_file, "w+")

        local split_list = misc.splitString(text, "\n")
        local user_line = "user:"..username.."." --TODO this shows us that we need some better format for the config file
        for _, line in ipairs(split_list) do
               if (line:sub(1, #user_line) ~= user_line) then
                       db:write(line.."\n")
               end
        end

end

function addUser(request)
        local req = parseRequest(request.body)

        --TODO verify input

        removeUserFromDB(req.username)

        db:seek("end")

        db:write("user:" .. req.username .. ".real_name=" .. req.real_name .. "\n")
        db:write("user:" .. req.username .. ".password=" .. req.password .. "\n")
        db:write("user:" .. req.username .. ".groups=" .. req.groups .. "\n")
        db:write("user:" .. req.username .. ".shell=" .. req.shell .. "\n")

        return { status=303, headers = {["Location"]="/#users"}, reason="ok", body = "TODO" }
end

function deleteUser(request)
        local username = request.matches[1]

        --TODO verify input

        --TODO maybe abstract this out
        removeUserFromDB(username)

        return { status=303, headers = {["Location"]="/#users"}, reason="ok", body = "TODO" }
end

function networkPage(request)
        local body = template.process(network_page,
        {
                theme = "cerulean",
                network_interfaces = network.getInterfaces(),
        })

        return { status=200, reason="ok", body = body }
end

function checkIsWireless(request)
        local isWireless = network.isWireless(request.matches[1])
        return {status=200, reason="ok", body=json.encode(isWireless)}
end

function scanWireless()
        local networks = network.scanWireless()
        return { status=200, reason="ok", body=json.encode(networks)}
end

function connectToNetwork(request)
        local req = parseRequest(request.body)
        local cfg = {}
        for key, val in pairs(req) do
                cfg[key] = val
                print(key, val)
        end

        --add wired support too...
        --and dhcp, slaac stuff
        --network.connectWireless(cfg.network, cfg.password)

        return { status=303, headers = {["Location"]="/"}, reason="ok", body = "TODO" }
end


function doInstall(request)
        local lines = splitString(request.body, "&")

        local distsets = ""
        local disks = ""

        local cfg = {}

        for i, line in ipairs(lines) do
                local mapping = unescape(line)

                local key, val = mapping:match("^([^=]+)=(.*)")
                if (key == "distsets") then
                        distsets = val .. " " .. distsets
                elseif (key == "disks") then
                        disks = val .. " " .. disks
                else
                        cfg[key] = val
                end
        end

        db:seek("end")
        for key, val in pairs(cfg) do
                db:write(key .. "=" .. val .. "\n") 
        end

        db:write("partitions=" .. disks .. "\n")
        db:write("distributions=" .. distsets .. "\n")

        return { status=501, reason="Not implemented", body="TODO" }
end

function debug_ClearDB()
        db:close()
        io.open(db_file, "w+"):close()
        db = io.open(db_file, "r+")
        return { status=303, headers = {["Location"]="/"}, reason="ok", body = "TODO" }
end

local server = httpd.create_server("/var/log/httpd.log")

server:add_route("GET", "^/debug/cleardb$", debug_ClearDB)

server:add_route("GET", "^/adduser$", addUserPage)
server:add_route("GET", "^/edituser/(.*)$", editUserPage)
server:add_route("GET", "^/network$", networkPage)
server:add_route("GET", "^/network/iswireless/(.*)$", checkIsWireless)
server:add_route("GET", "^/scanwireless$", scanWireless)
server:add_route("GET", "^/keymap$", keymapPage)
server:add_route("GET", "^/keymap/variants/(.*)$", getVariants)
server:add_route("GET", "^/(.*)$", mainPage)

server:add_route("POST", "^/install$", doInstall)
server:add_route("POST", "^/adduser$", addUser)
server:add_route("POST", "^/deleteuser/(.*)$", deleteUser)
server:add_route("POST", "^/network$", connectToNetwork)
server:add_route("POST", "^/keymap$", setKeymap)
server:run(true)
